24/04/2023

3-tier architecture: 
- Client/browser(HTML/CSS/JS)
- Web application server 
- Database/Enterprise Information Systems Tier(EIS)
(If you include cloud components, then it would be 4-tier/5-tier architecture)

NOTE: Java is robust enough for enterprise applications; Python only for standalone applications.

Web Servers: Apache Tomcat; Glassfish; JBoss; WebLogic 
- Web Tier: Java Servlet; Java Server Pages (JSP);Java Server Faces (JSF); this layer is the equivalent of React.
- Business Tier: EJB; SpringBoot; this layer applies business logic to data collected by the Web Tier.

OOP:
- Objects are reusable, non-sequential, and maintainable.
- Compared with procedure programming.

Java:
- SECURE: All java code must be run by the JVM, which includes its own security checks.
- Better memory management and exception handling.
- Specifications:
  - Java Standard Edition (SE): aka 'Core Java'. Used for desktop/console applications.
  - Java Enterprise Edition (EE): Used for business applications. 
  - Java Mobile Edition (ME): Used for mobile applications.

Datatypes
- Primitive vs object types
- Primitive types:
  - Byte (a byte is 8-bits; so the values it can represent is 2^8 bits = 256 values). The actual value range is -128 to +127.
  - Boolean: Size of actual boolean value depends on the operating system.
  - Char: 2 bytes - one is for ASCII; the other is for UNICODE.
- Object types:
	- Java arrays MUST contain the same type, AND you must declare the array size. That is why it is called a 'static array'. To create an array with dynamic size, use 'ArrayList'. e.g.
	
	anArray = new int[10];
	int[] myNum = {10, 20, 30, 40};

Java type coercion:
- e.g.
	int a = 100;
	long b = 20;

	int c = a + b;

	- Java does type coercion based on the variable with maximum memory. That is why it is called 'widening conversion'.
	- In this case, the variable 'b' has the most memory at 8 bytes (because long).
	- Therefore, the above equation will return an error because the result is a long type but the variable has only been assigned 4 bytes (int type).
- NOTE: Strongly typed languages do not allow for type coercion, but Java is a strongly typed language, so why is the above allowed? This is because behind the scenes, the compiler will turn implicit coercion into explicit, e.g. a + b => long(a) + b

Java type casting:
- NOTE: Type casting can be applied to compatible data types as well as incompatible data types, whereas the compiler will only recognise implicit type coercion with compatible types.
- Also, the destination data type can be smaller than the source data type. That is why it is 'narrowing conversion'.

Java operators:
- Unary operators: e.g.
	int a = 10;
	int b = a++;
	System.out.println(a);
	System.out.println(b);

- In the above example, the program will return 11 then 10.
- This is because postfix version evaluates to the origin value, while prefix version returns the new value.

- Boolean operators:
	int c = a & b;
	- 'a' and 'b' is converted to binary, and boolean algebra is applied to them.

- Also be aware of operator precedence:
	System.out.println(++a+b);
	- Unary operator '++' will be applied first to 'a', and because it is prefix it will return the new value. Then that value is added to 'b', yielding the result 22.

Java control flow:
- NOTE Java 'enhanced for' loop => 'for-each' loop over collection. However, you can only access the array values, and cannot reassign them.
	for (type variableName : arrayName) {

	}

OOP
1. What is a class?
- A user-defined datatype
- Syntax:

	[access-specifier] class <ClassName>{
		
	}

2. What is an object?
- A combination of state and behaviours.
- The process of creating objects from a class declaration is called INSTANTIATION.

3. What is a method?
- A block of code that can be declared once and called many times.
- A method has 'worker-manager association':
	- Method definition = Worker
	- Method call = Manager
		- e.g. range(0,5) - this is CALL BY VALUE.
- A 'function' is a block can exist on its own. THerefore Java does not have functions; all methods must exist within a class.
- Method syntax:

  [access-specifier] return-type <methodName>([parameter-list]){
  
  }



4. OOP design in Java:
Static Class
Final Class
Abstract Class
Concrete Class
Singleton Class
POJO Class
Inner Class

- Model class/ POJO (plain old Java Object) class:
	- Contains private variables and their Getters and Setters.
	- Javabeans standard forces you to use getters/setters.

5. OOP thinking:
- 4 pillars of Object-oriented programming:
	- START WITH Encapsulation (data and methods together)
	- Inheritance
	- Abstraction
	- Polymorphism
- https://www.yegor256.com/2014/09/16/getters-and-setters-are-evil.html


- Constructor:
		- Has the SAME NAME as the class in which it is declared.
		- It is called IMMEDIATELY upon creation of an object.
		- Lacks return type. This means DO NOT declare 'void'; ie it does not follow method syntax. While void doesn't return a value in the strictest sense of the word, it is still considered a return type.
	- Constructor method is responsible for creating an object from a class template. So if you do not define a constructor in your class, the compiler will add one for you. 
	


Variables:
- Global, local, instance variables (declared using 'this.')
- Local variables get highest priority






xx3. Call Stack and Memory Heap
- Heap and stack are generic terms for ways in which memory can be allocated. It is an implementation of a MEMORY MODEL.
	- Memory models came into existence with high-level programming languages. Before they came along, people used assembly languages, or other means of programming which for the most part used a memory model indistinguishable from the computer's real memory. This is 'flat memory model'. See types of memory models: https://www.cs.auckland.ac.nz/~alan/courses/os/book/4.How.02.memorymod.pdf; http://canonical.org/~kragen/memory-models/; https://www.memorymanagement.org/index.html
	- History of the use of stack-heap architecture: https://www.sigcis.org/files/A%20brief%20history.pdf
	- Memory management in stack is done in LIFO manner whereas it’s more complex in Heap memory because it’s used globally. Heap memory is divided into Young-Generation, Old-Generation etc, more details at Java Garbage Collection.
	- Another performance hit for the heap is that the heap, being mostly a global resource, typically has to be multi-threading safe, i.e. each allocation and deallocation needs to be - typically - synchronized with "all" other heap accesses in the program.

- How are stacks and heaps related to programming languages:
	- Heaps are bad at fast memory allocation and deallocation. If you want to grab many tiny amounts of memory for a limited duration, a heap is not your best choice. A stack, with its super-simple allocation / deallocation algorithm, naturally excels at this (even more so if it is built into the hardware)
	- Stacks are adopted by many programming languages because they are perfect fit for scoped variables, e.g. create new stack frame at the beginning of a function, and discard it when leaving.
		- Language implementations without a stack are typically implemented using the continuation-passing style. See: https://stackoverflow.com/questions/796211/what-does-it-really-mean-that-a-programming-language-is-stackless
		- From a formal methods perspective the heap and stack correspond to the "Store" and "Kontinuation" of a CESK machine (Control Environment Store Kontinuation.)
	- Local Variables that only need to last as long as the function invocation go in the stack. In most languages it's critical that we know at compile time how large a variable is if we want to store it on the stack.
	- The heap is used for variables whose lifetime we don't really know up front but we expect them to last a while. In many languages the heap is garbage collected to remove objects that no longer have any references.

- How are stacks and heaps related to OOP:
	- Stack-and-heap is linked to the history of OOP: During the creation of ALGOL, the creators realized that an inner function can be contained within a function with a local variables, and the inner function can access the local variables of the outer function. This was implemented by moving the variables to the heap from the stack (https://youtu.be/t86v3N4OshQ?t=846).

- Process:
e.g. 

public void Method1()
{
    int i = 4;
    int y = 2;
    class1 cls1 = new class1();
}

'i = 4' goes into the stack.
'y = 2' goes into the stack; stack is LIFO, so this sits on top of 'i = 4'
'cls1' REFERENCE goes into the stack; 'cls1' object goes into the heap.
'}' terminates the method. Stack is emptied; 'cls1' remains in heap.


- Each thread gets a stack, while there's typically only one heap for the application.
	- A thread is a sequential flow of control. This sounds like processes!
	- The difference: threads run in a shared memory space within ONE process;  processes run in separate memory spaces.  (See history: http://www.serpentine.com/blog/threads-faq/the-history-of-threads/)

 

















==============================================
. The reason why the stack / heap distinction is important is because of scope.

struct S { ... }

void f() {
    var x = new S();
    ...
 }
 
Once x goes out of scope, the object that was created is categorically gone. That is only because it is allocated on the stack, not the heap. There is nothing that could have gone in in the "..." part of the method that can change that fact. In particular, any assignments or method calls could only have made copies of the S struct, not created new references to it to enable it to keep living.

class C { ... }

void f() {
     var x = new C();
     ...
}

Totally different story! Since x is now on the heap, its object (that is, the object itself, not a copy of it) could very well continue to live on after x goes out of scope. In fact, the only way it won't continue to live is if x is the only reference to it. If assignments or method calls in the "..." part have created other references that are still "live" by the time x goes out of scope, then that object will continue living.


