15/05/2023
===============
SOLID Principles
- The below principles all lead to each other, e.g. single responsibility can be extended to give effect to open/close, and Liskov substitution principle reminds you to write o/c relationships in a better way.

- Single responsibility
	- Specific way to design classes

	class Employee{
		private int employeeId;
		private String employeeName;

		private int productId; //  This is irrelevant to employee object
	}

	- Classes should only change for ONE reason: to alterate RELEVANT characteristics to the class. 
		- Do not add business methods to a domain class, e.g. "Payment" class should not contain "debitPayment"; that should belong to "PaymentService" class.
		- If the class is a "View" class, it should only focus on view; if the class is a service class, it should only do that. To couple classes together, you can use the MVC pattern.

- O (open/close)
	 Open for extension; closed for modification.
		- Single responsibility is about the class itself; O/C is about how to extend them.
			- Focuses on inheritance. Inheritance is about maintenance; it aims to make it easy to add features. Ways to add features: 
				- Top down approach: Extending existing classes
				- Bottom up approach: Grouping classes into a new supertype
	- Consider administration privileges - how would you implement it?
	
		class Employee{
			private int employeeId;
			private String employeeName;

		}

		class Admin extends Employee{

		}	

- Liskov substitution rule
	- Also related to inheritance
	- Basically, LSR means your code should be as polymorphic as possible.
		- Embrace using supertypes over subtypes, e.g. 
			public void printItems(Arraylist<String> items)
				is inferior to:
			public void printItems(List<String> items)

	- Consider:	
	class Employee{

	}

	class Managre extends Employee[

	}

	class Admin extends Manager{

	}

	Employee e1 = new Manager(); // This is possible

	e1 = new Admin(); // Possible

	Manager m1 = new Admin(); // Not possible - subtype cannot refer to supertype

- Interface segregation
	- When declaring interfaces, make sure you only add what is necessary. If there are a lot of methods, decompose your interface.

	interface DocumentService{
		public void print();
		public void scan();
		public void fax();
	}

	class PrinterService implements DocumentService{
		// Printer does not need to implement scan or fax.
	}

- Don't force developers to implement all methods.
- Keeps code loosely coupled.

- Dependecy Inversion Rule
	- High level modules should not depend on low level modules. 
	- Abstractions should not depend on details. Details should depend on abstractions.
	- Consider the below:

	class EmployeeService{
		private EmployeeDAOInMemoryImpl employeeDAOInMemoryImpl;

		private EmployeeDAODatabaseImpl employeeDAODatabaseImpl;

		public EmployeeeServiceImpl(EmployeeDAOInMemoryImpl employeeDAOInMemoryImpl){
		}
	}
	
	- The references to specific implementations result in very tight couplling. Both EmployeeService and EmployeeDAO should depend on abstractions.
	- Every object that the class relies on, create it somewhere else and pass it to the class.
===============
OOP architecture - Domain Driven Design:
- The domain is mapped by models. They should not contain behaviour, only data (single responsibility principle).
- OOP means combining state and behaviour, so models are the 'state', and services are the 'behaviour'.



===============
- Refactoring: Changing existing code WITHOUT changing the functionality. 
===============
JDBC API (Java Database Connectivity)
- API acts as a bridge.
- JDBC specifically provides a set of classes and interfaces for Java applications to connect and execute SQL queries.
- Interfaces:
	- Connection
	- Statement
	- PreparedStatement
	- CallableStatement
	- ResultSet
- Classes:
	- DriverManager
	- Date
- JDBC App steps:
	- Load the driver class and register with DriverManager
		import java.sql.Connection; // For connection object
		// No need for import statement; the below statement is enough
		Class.forName("com.mysql.jdbc.Driver");

	- Establish connect/ create connection object

		Connection con = DriverManager.getConnection("jdbc:mysql://localhost/test","root",""); // This is a static method.

	// jdbc:mysql - this is the protocol
	// localHost - host name
	// test - database name
	// root - database username
	// final field - password

	- Prepare/create courier serivce/statement object

		// Database (test) table: employee (employee_id, first_name, last_name)
		PreparedStatement pst = con.prepareStatement("INSERT into employee(employee_id, first_name, last_name) VALUES(?,?,?));

		pst.setInt(1,100);
		pst.setString(2,"Tom");
		pst.setString(3,"Lee");

	- Execute the statement/query

		pst.executeUpdate(); // This method is used to execute "INSERT,UPDATE,DELETE" commands. Notice "SELECT" is not here, because unlike the other three, "SELECT" returns rows of data, instead of a report of the qty of changes, e.g. 3 lines deleted.

	- Close the established connection.

		pst.close();
		con.close();

===============
Servlets and JSP APIs 
- Servlet is a server-side web component responsible for generating dynamic content.
- Servlet response is in plain  text or HTML.	
- What is an Applet?
	- Downloadable components that enables client-side rendering
- Web server examples:
	- IIS (from Microsoft)
	- Apache Tomcat
- Application servers extend web servers with additional features:
	- Contains a container for web and business components (HTML, Servlet, JSP and EJB)
	- Glassfish, JBoss, BEA web logic
=====
Eclipse IDE
- For "new project" you can select "dynamic web project"
	- This will create the necessary file structure for you.
- "src/main/java" - server-side
	- Need to install Apache Tomcat and direct Eclipse to the server directory.
	- "request.setAttribute("logDate", var)" stores server-side variable in the response.
	- the "request.getResquestDispatcher('newPage.jsp').forward(request,response)" methods will send the new html page to client
- "src/main/webapp" - client-side view; static resources
	- JSP
		- "Scriptlet" is defined by <% %>
		- request.getAttribute("logDate") extracts the data from server response and displays it. 

=========
Applying OOP to web app architecture
- Servlets act as controllers.
- No need to write view because that is taken up by the browser frontend.
- Sessions:
	HttpSession session = 

	and for JSP...

	(Employee) session.getAttribute()

========
Session Managemnt/Tracking
- What is "http" protocol?
	- Stateless protocol: Server discards client-specific information once response is sent.
- Session tracking: Server retains client information, e.g. remembering basket information.
	- Types of session management:
		- Cookies: Plain text containing user information, e.g. IP address, user password. (Stored in client side!)
			- "Cookie" is a predefined class in Java:
				Cookie c1 = new Cookie("userName", "Aaron")
				response.addCookie(c1); 
				Cookie[] cookies = request.getCookies(); // Receives an array of cookies
		- Session object: Created and maintained in server-side. 
			- The session ID and associated data could be stored in database; usually encrypted.
				- Session hijacking: Impersonating another user via accessing their session ID. 
			- Example:
				// Servlet 1
				HttpSession session = request.getSession(true);
				session.setAttribute("username","Aaron"); // "username" is called "session label"

				// Servlet 2
				HttpSession session = request.getSession(true);
				String username = (String) session.getAttribute("username","Aaron"); // Return type is object so need to typecast it.

		- URL rewriting
		- Hidden fields: Not visible in webpage, but their values can be sent to the server. 	
	- NOTE: Each browser is a client. So session is linked with specific browser, i.e. if Chrome pings a server, the data there is not reflected if Edge pings the same server.

